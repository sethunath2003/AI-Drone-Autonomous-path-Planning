/*
 * ITERATION 7: Lidar Obstacle Avoidance (Sector Logic)
 * - FEATURES:
 * 1. Sector Detection: Scans Left, Center, and Right.
 * 2. Smart Avoidance: Turns towards the most open space.
 * 3. Logging: Prints warnings and specific actions to console.
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#include <webots/robot.h>
#include <webots/lidar.h>
#include <webots/gps.h>
#include <webots/gyro.h>
#include <webots/inertial_unit.h>
#include <webots/motor.h>
#include <webots/keyboard.h>

// === UTILITIES ===
#define CLAMP(value, low, high) ((value) < (low) ? (low) : ((value) > (high) ? (high) : (value)))
#define PI 3.14159265358979323846

// === TUNING CONSTANTS ===
const double k_vertical_thrust = 68.5;
const double k_vertical_offset = 0.6;
const double k_vertical_p = 3.0;
const double k_roll_p = 50.0;
const double k_pitch_p = 30.0;
const double k_yaw_p = 2.0;
const double k_yaw_d = 5.0;

// ODA TUNING
const double obstacle_threshold = 2.0; // Detect obstacles 2m away
const double avoid_speed = 1.0;        // How fast to turn when avoiding

const double waypoint_tolerance = 1.0;

typedef struct { double x, y, z; } Waypoint;
#define MAX_WAYPOINTS 10
Waypoint path[MAX_WAYPOINTS];
int total_waypoints = 0;
int current_wp_index = 0;

int main(int argc, char **argv) {
  wb_robot_init();
  int timestep = (int)wb_robot_get_basic_time_step();

  // === USER VARIABLES ===
  bool land_mode = false;
  int avoid_counter = 0; // To prevent log spamming

  // === WAYPOINTS ===
  path[0].x = -29.0;  path[0].y = 0.0; path[0].z = 1.0;
  path[1].x = 0.0;    path[1].y = 0.0;   path[1].z = 2.0;
  total_waypoints = 2;

  // === DEVICES ===
  WbDeviceTag imu = wb_robot_get_device("inertial unit");
  wb_inertial_unit_enable(imu, timestep);
  WbDeviceTag gps = wb_robot_get_device("gps");
  wb_gps_enable(gps, timestep);
  WbDeviceTag gyro = wb_robot_get_device("gyro");
  wb_gyro_enable(gyro, timestep);
  
  // LIDAR SETUP
  WbDeviceTag lidar = wb_robot_get_device("lidar");
  wb_lidar_enable(lidar, timestep);
  int lidar_width = wb_lidar_get_horizontal_resolution(lidar); // e.g. 512 points
  
  wb_keyboard_enable(timestep);

  WbDeviceTag front_left_motor = wb_robot_get_device("front left propeller");
  WbDeviceTag front_right_motor = wb_robot_get_device("front right propeller");
  WbDeviceTag rear_left_motor = wb_robot_get_device("rear left propeller");
  WbDeviceTag rear_right_motor = wb_robot_get_device("rear right propeller");
  
  WbDeviceTag motors[4] = {front_left_motor, front_right_motor, rear_left_motor, rear_right_motor};
  for (int m = 0; m < 4; ++m) {
    wb_motor_set_position(motors[m], INFINITY);
    wb_motor_set_velocity(motors[m], 1.0);
  }

  printf(">> ODA SYSTEM ONLINE. Initializing...\n");

  while (wb_robot_step(timestep) != -1) {
    
    // 1. INPUTS
    int key = wb_keyboard_get_key();
    while (key > 0) {
        if (key == 'L') {
            land_mode = !land_mode;
            if (land_mode) printf(">> COMMAND: LANDING!\n");
            else printf(">> COMMAND: RESUMING FLIGHT!\n");
        }
        key = wb_keyboard_get_key();
    }

    // 2. SENSORS
    const double *rpy = wb_inertial_unit_get_roll_pitch_yaw(imu);
    double roll = rpy[0];
    double pitch = rpy[1];
    double yaw = rpy[2];

    const double *gps_vals = wb_gps_get_values(gps);
    double cur_x = gps_vals[0];
    double cur_y = gps_vals[1];
    double cur_alt = gps_vals[2];
    
    const double *gyro_vals = wb_gyro_get_values(gyro);
    double yaw_velocity = gyro_vals[2];

    // 3. FLIGHT LOGIC
    double target_z = 2.0; 
    double pitch_cmd = 0.0;
    double roll_cmd = 0.0;
    double yaw_cmd = 0.0;

    if (land_mode) {
        // ... (Same Landing Logic as before) ...
        target_z = 0.0;
        pitch_cmd = 0.0; roll_cmd = 0.0; yaw_cmd = 0.0;
        if (cur_alt < 0.15) {
            for(int i=0; i<4; i++) wb_motor_set_velocity(motors[i], 0);
            continue;
        }
    } 
    else {
        // === LIDAR SECTOR LOGIC ===
        // Get Lidar Array (Usually 0 is Right, width-1 is Left in Webots, or vice versa depending on model)
        // We will sample 3 points to define sectors
        const float *lidar_values = wb_lidar_get_range_image(lidar);
        
        // Define indices (assuming 0 to width spans roughly 180 degrees or FOV)
        int right_idx = lidar_width * 0.25;  // Right side scan
        int center_idx = lidar_width * 0.5;  // Center scan
        int left_idx = lidar_width * 0.75;   // Left side scan
        
        double dist_right = lidar_values[right_idx];
        double dist_center = lidar_values[center_idx];
        double dist_left = lidar_values[left_idx];

        // Sanity check for infinity (no obstacle)
        if(isinf(dist_right)) dist_right = 100.0;
        if(isinf(dist_center)) dist_center = 100.0;
        if(isinf(dist_left)) dist_left = 100.0;

        bool obstacle_detected = (dist_center < obstacle_threshold);

        if (obstacle_detected) {
            // === AVOIDANCE MODE ===
            
            // Log only occasionally to avoid console lagging
            avoid_counter++;
            if (avoid_counter % 10 == 0) { 
                printf(">> WARNING: OBSTACLE AHEAD! (Dist: %.2fm)\n", dist_center);
            }

            // Stop moving forward
            pitch_cmd = 0.0; 

            // Decide Direction
            if (dist_left > dist_right) {
                // Left is clearer
                if (avoid_counter % 10 == 0) printf(">> ACTION: TURNING LEFT\n");
                yaw_cmd = avoid_speed; 
            } else {
                // Right is clearer
                if (avoid_counter %